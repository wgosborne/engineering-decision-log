// ============================================================================
// DECISIONS SERVICE - Business Logic Layer
// ============================================================================
// Purpose: Centralized database operations and business logic for decisions
// Usage: Import these functions in API routes to handle CRUD operations
// Database: Works with Supabase PostgreSQL client
// Note: Uses browser client - these functions should be refactored to accept
//       a server client parameter when called from API routes
// ============================================================================

import { createClient } from '@/lib/supabase/client';
import {
  Decision,
  NewDecision,
  UpdateDecision,
  DecisionFilters,
  DecisionCategory,
  OptimizedFor,
  DecisionType,
} from '@/lib/types/decisions';

// Create a client instance for these service functions
// TODO: Refactor to accept client as parameter from API routes
const supabase = createClient();

// ============================================================================
// TYPES
// ============================================================================

export interface ListDecisionsParams {
  search?: string;
  category?: DecisionCategory;
  project?: string;
  tags?: string[];
  confidence_min?: number;
  confidence_max?: number;
  outcome_status?: 'all' | 'pending' | 'success' | 'failed';
  flagged?: boolean;
  sort?: 'date-desc' | 'date-asc' | 'confidence-desc' | 'confidence-asc';
  limit?: number;
  offset?: number;
}

export interface ListDecisionsResult {
  decisions: Decision[];
  total: number;
  hasMore: boolean;
}

export interface AnalyticsSummary {
  total_decisions: number;
  decisions_by_category: Record<string, number>;
  success_rate_by_category: Record<string, number>;
  optimized_for_frequency: Record<string, number>;
  tradeoffs_accepted_frequency: Record<string, number>;
  tradeoffs_rejected_frequency: Record<string, number>;
  average_confidence: number;
  decisions_with_outcomes: number;
  overall_success_rate: number;
  flagged_for_review_count: number;
  decisions_past_review_date: number;
}

export interface SimilarLinkData {
  similar_to_id: string;
  reason: string;
  comparison: string;
}

export interface OutcomeUpdateData {
  outcome_success: boolean;
  outcome: string;
  lessons_learned?: string;
  outcome_date?: string;
}

export interface FlagForReviewData {
  flagged: boolean;
  next_review_date?: string;
  revisit_reason?: string;
}

// ============================================================================
// CREATE OPERATION
// ============================================================================

/**
 * Create a new decision
 * @param data - Decision data (without id, timestamps)
 * @returns Created decision with generated id and timestamps
 * @throws Error if validation fails or database operation fails
 */
export async function createDecision(
  data: Omit<NewDecision, 'date_created' | 'date_updated' | 'search_vector'>
): Promise<Decision> {
  // Insert into database (id, timestamps auto-generated by PostgreSQL)
  const { data: decision, error } = await supabase
    .from('decisions')
    .insert({
      ...data,
      // Ensure arrays are properly formatted
      tags: data.tags || [],
      stakeholders: data.stakeholders || [],
      tradeoffs_accepted: data.tradeoffs_accepted || [],
      tradeoffs_rejected: data.tradeoffs_rejected || [],
      optimized_for: data.optimized_for || [],
      assumptions: data.assumptions || [],
      invalidation_conditions: data.invalidation_conditions || [],
      options_considered: data.options_considered || [],
      similar_decision_ids: data.similar_decision_ids || [],
      related_decision_ids: data.related_decision_ids || [],
      similarity_notes: data.similarity_notes || [],
      // Set defaults
      flagged_for_review: data.flagged_for_review ?? false,
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating decision:', error);
    throw new Error(`Failed to create decision: ${error.message}`);
  }

  return decision as Decision;
}

// ============================================================================
// READ OPERATIONS
// ============================================================================

/**
 * Get a single decision by ID
 * @param id - UUID of the decision
 * @returns Decision object or null if not found
 */
export async function getDecisionById(id: string): Promise<Decision | null> {
  const { data: decision, error } = await supabase
    .from('decisions')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      // Not found
      return null;
    }
    console.error('Error fetching decision:', error);
    throw new Error(`Failed to fetch decision: ${error.message}`);
  }

  return decision as Decision;
}

/**
 * List decisions with filtering, search, and pagination
 * @param params - Filter and pagination parameters
 * @returns Array of decisions with pagination metadata
 */
export async function listDecisions(
  params: ListDecisionsParams = {}
): Promise<ListDecisionsResult> {
  const {
    search,
    category,
    project,
    tags,
    confidence_min,
    confidence_max,
    outcome_status = 'all',
    flagged,
    sort = 'date-desc',
    limit = 20,
    offset = 0,
  } = params;

  // Start building query
  let query = supabase.from('decisions').select('*', { count: 'exact' });

  // Apply filters
  if (search) {
    // Full-text search using PostgreSQL's plainto_tsquery for better typo handling
    // Uses 'simple' config to avoid filtering stop words (have, the, is, etc.)
    query = query.textSearch('search_vector', search, {
      type: 'plain',
      config: 'simple',
    });
  }

  if (category) {
    query = query.eq('category', category);
  }

  if (project) {
    query = query.eq('project_name', project);
  }

  if (tags && tags.length > 0) {
    // Filter by tags (PostgreSQL array overlap operator)
    query = query.overlaps('tags', tags);
  }

  if (confidence_min !== undefined) {
    query = query.gte('confidence_level', confidence_min);
  }

  if (confidence_max !== undefined) {
    query = query.lte('confidence_level', confidence_max);
  }

  if (outcome_status !== 'all') {
    if (outcome_status === 'pending') {
      query = query.is('outcome_success', null);
    } else if (outcome_status === 'success') {
      query = query.eq('outcome_success', true);
    } else if (outcome_status === 'failed') {
      query = query.eq('outcome_success', false);
    }
  }

  if (flagged !== undefined) {
    query = query.eq('flagged_for_review', flagged);
  }

  // Apply sorting
  switch (sort) {
    case 'date-desc':
      query = query.order('date_created', { ascending: false });
      break;
    case 'date-asc':
      query = query.order('date_created', { ascending: true });
      break;
    case 'confidence-desc':
      query = query.order('confidence_level', { ascending: false, nullsFirst: false });
      break;
    case 'confidence-asc':
      query = query.order('confidence_level', { ascending: true, nullsFirst: false });
      break;
  }

  // Apply pagination
  const cappedLimit = Math.min(limit, 100); // Max 100 per request
  query = query.range(offset, offset + cappedLimit - 1);

  // Execute query
  const { data: decisions, error, count } = await query;

  if (error) {
    console.error('Error listing decisions:', error);
    throw new Error(`Failed to list decisions: ${error.message}`);
  }

  const total = count || 0;
  const hasMore = offset + cappedLimit < total;

  return {
    decisions: (decisions as Decision[]) || [],
    total,
    hasMore,
  };
}

/**
 * Get analytics summary for dashboard
 * @param period - Time period to analyze ('week' | 'month' | 'quarter' | 'all')
 * @param category - Optional category filter
 * @returns Aggregated analytics data
 */
export async function getAnalyticsSummary(
  period: 'week' | 'month' | 'quarter' | 'all' = 'month',
  category?: DecisionCategory
): Promise<AnalyticsSummary> {
  // Calculate date filter based on period
  const now = new Date();
  let dateFilter: string | null = null;

  switch (period) {
    case 'week':
      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      dateFilter = weekAgo.toISOString();
      break;
    case 'month':
      const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      dateFilter = monthAgo.toISOString();
      break;
    case 'quarter':
      const quarterAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      dateFilter = quarterAgo.toISOString();
      break;
    case 'all':
      dateFilter = null;
      break;
  }

  // Fetch decisions for the period
  let query = supabase.from('decisions').select('*');

  if (dateFilter) {
    query = query.gte('date_created', dateFilter);
  }

  if (category) {
    query = query.eq('category', category);
  }

  const { data: decisions, error } = await query;

  if (error) {
    console.error('Error fetching analytics data:', error);
    throw new Error(`Failed to fetch analytics: ${error.message}`);
  }

  const allDecisions = (decisions as Decision[]) || [];

  // Calculate aggregations
  const total_decisions = allDecisions.length;

  // Decisions by category
  const decisions_by_category: Record<string, number> = {};
  allDecisions.forEach((d) => {
    decisions_by_category[d.category] = (decisions_by_category[d.category] || 0) + 1;
  });

  // Success rate by category
  const success_rate_by_category: Record<string, number> = {};
  const categoryStats: Record<string, { total: number; successful: number }> = {};

  allDecisions.forEach((d) => {
    if (d.outcome_success !== null) {
      if (!categoryStats[d.category]) {
        categoryStats[d.category] = { total: 0, successful: 0 };
      }
      categoryStats[d.category].total++;
      if (d.outcome_success) {
        categoryStats[d.category].successful++;
      }
    }
  });

  Object.keys(categoryStats).forEach((cat) => {
    const stats = categoryStats[cat];
    success_rate_by_category[cat] = Math.round((stats.successful / stats.total) * 100);
  });

  // Optimized for frequency
  const optimized_for_frequency: Record<string, number> = {};
  allDecisions.forEach((d) => {
    d.optimized_for?.forEach((opt) => {
      optimized_for_frequency[opt] = (optimized_for_frequency[opt] || 0) + 1;
    });
  });

  // Tradeoffs accepted frequency
  const tradeoffs_accepted_frequency: Record<string, number> = {};
  allDecisions.forEach((d) => {
    d.tradeoffs_accepted?.forEach((tradeoff) => {
      tradeoffs_accepted_frequency[tradeoff] =
        (tradeoffs_accepted_frequency[tradeoff] || 0) + 1;
    });
  });

  // Tradeoffs rejected frequency
  const tradeoffs_rejected_frequency: Record<string, number> = {};
  allDecisions.forEach((d) => {
    d.tradeoffs_rejected?.forEach((tradeoff) => {
      tradeoffs_rejected_frequency[tradeoff] =
        (tradeoffs_rejected_frequency[tradeoff] || 0) + 1;
    });
  });

  // Average confidence
  const decisionsWithConfidence = allDecisions.filter((d) => d.confidence_level !== null);
  const average_confidence =
    decisionsWithConfidence.length > 0
      ? Math.round(
          (decisionsWithConfidence.reduce((sum, d) => sum + (d.confidence_level || 0), 0) /
            decisionsWithConfidence.length) *
            100
        ) / 100
      : 0;

  // Decisions with outcomes
  const decisions_with_outcomes = allDecisions.filter((d) => d.outcome_success !== null).length;

  // Overall success rate
  const successfulDecisions = allDecisions.filter((d) => d.outcome_success === true).length;
  const overall_success_rate =
    decisions_with_outcomes > 0
      ? Math.round((successfulDecisions / decisions_with_outcomes) * 100)
      : 0;

  // Flagged for review count
  const flagged_for_review_count = allDecisions.filter((d) => d.flagged_for_review).length;

  // Decisions past review date
  const today = new Date().toISOString().split('T')[0];
  const decisions_past_review_date = allDecisions.filter(
    (d) => d.next_review_date && d.next_review_date < today
  ).length;

  return {
    total_decisions,
    decisions_by_category,
    success_rate_by_category,
    optimized_for_frequency,
    tradeoffs_accepted_frequency,
    tradeoffs_rejected_frequency,
    average_confidence,
    decisions_with_outcomes,
    overall_success_rate,
    flagged_for_review_count,
    decisions_past_review_date,
  };
}

// ============================================================================
// UPDATE OPERATION
// ============================================================================

/**
 * Update an existing decision
 * @param id - UUID of the decision to update
 * @param data - Partial decision data to update
 * @returns Updated decision object
 * @throws Error if decision not found or update fails
 */
export async function updateDecision(
  id: string,
  data: Partial<Omit<Decision, 'id' | 'date_created' | 'date_updated' | 'search_vector'>>
): Promise<Decision> {
  // date_updated will be auto-set by trigger
  const { data: decision, error } = await supabase
    .from('decisions')
    .update(data)
    .eq('id', id)
    .select()
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      throw new Error('Decision not found');
    }
    console.error('Error updating decision:', error);
    throw new Error(`Failed to update decision: ${error.message}`);
  }

  return decision as Decision;
}

// ============================================================================
// DELETE OPERATION
// ============================================================================

/**
 * Delete a decision (hard delete)
 * @param id - UUID of the decision to delete
 * @returns Deleted decision id
 * @throws Error if decision not found or delete fails
 */
export async function deleteDecision(id: string): Promise<string> {
  const { error } = await supabase.from('decisions').delete().eq('id', id);

  if (error) {
    console.error('Error deleting decision:', error);
    throw new Error(`Failed to delete decision: ${error.message}`);
  }

  return id;
}

// ============================================================================
// SPECIAL OPERATIONS
// ============================================================================

/**
 * Mark a decision as similar to another
 * @param id - UUID of the current decision
 * @param linkData - Similar decision link data
 * @returns Updated decision with new similar link
 */
export async function markSimilarDecision(
  id: string,
  linkData: SimilarLinkData
): Promise<Decision> {
  // Fetch current decision
  const currentDecision = await getDecisionById(id);
  if (!currentDecision) {
    throw new Error('Decision not found');
  }

  // Verify the similar decision exists
  const similarDecision = await getDecisionById(linkData.similar_to_id);
  if (!similarDecision) {
    throw new Error('Similar decision not found');
  }

  // Check if already linked
  const alreadyLinked = currentDecision.similar_decision_ids?.includes(linkData.similar_to_id);
  if (alreadyLinked) {
    throw new Error('Decisions are already linked as similar');
  }

  // Update similar_decision_ids and similarity_notes
  const updatedSimilarIds = [
    ...(currentDecision.similar_decision_ids || []),
    linkData.similar_to_id,
  ];

  const updatedSimilarityNotes = [
    ...(currentDecision.similarity_notes || []),
    {
      related_decision_id: linkData.similar_to_id,
      reason: linkData.reason,
      comparison: linkData.comparison,
    },
  ];

  return updateDecision(id, {
    similar_decision_ids: updatedSimilarIds,
    similarity_notes: updatedSimilarityNotes,
  });
}

/**
 * Update decision outcome (after decision plays out)
 * @param id - UUID of the decision
 * @param outcomeData - Outcome data
 * @returns Updated decision with outcome
 */
export async function setDecisionOutcome(
  id: string,
  outcomeData: OutcomeUpdateData
): Promise<Decision> {
  const updateData: Partial<Decision> = {
    outcome_success: outcomeData.outcome_success,
    outcome: outcomeData.outcome,
    lessons_learned: outcomeData.lessons_learned,
    outcome_date: outcomeData.outcome_date || new Date().toISOString(),
  };

  return updateDecision(id, updateData);
}

/**
 * Flag or unflag a decision for review
 * @param id - UUID of the decision
 * @param flagData - Flag data
 * @returns Updated decision
 */
export async function flagDecisionForReview(
  id: string,
  flagData: FlagForReviewData
): Promise<Decision> {
  const updateData: Partial<Decision> = {
    flagged_for_review: flagData.flagged,
    next_review_date: flagData.next_review_date,
    revisit_reason: flagData.revisit_reason,
  };

  return updateDecision(id, updateData);
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Check if a UUID is valid
 * @param uuid - String to validate
 * @returns True if valid UUID
 */
export function isValidUUID(uuid: string): boolean {
  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

/**
 * Validate that a value is in an enum
 * @param value - Value to check
 * @param enumObj - Enum object
 * @returns True if value is in enum
 */
export function isValidEnumValue<T extends Record<string, string>>(
  value: string,
  enumObj: T
): value is T[keyof T] {
  return Object.values(enumObj).includes(value);
}
